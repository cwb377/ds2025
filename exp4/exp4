#include <iostream>
#include <vector>
#include <ctime>
#include <cstdlib>
#include <algorithm>
#include <iomanip>  // 修正：去掉多余的左尖括号，正确引入
#include <cmath>
#include <string>

using namespace std;

// 边界框结构体（位置、大小、置信度）
struct BoundingBox {
    float x1;    // 左上角x
    float y1;    // 左上角y
    float x2;    // 右下角x
    float y2;    // 右下角y
    float score; // 置信度
};

// 1. 排序算法实现（四种核心算法，按置信度降序）
// 1.1 快速排序（递归版）
void quickSort(vector<BoundingBox>& arr, int left, int right) {
    if (left >= right) return;
    float pivot = arr[(left + right) / 2].score;
    int i = left, j = right;
    while (i <= j) {
        while (arr[i].score > pivot) i++; // 降序：找比基准小的
        while (arr[j].score < pivot) j--; // 降序：找比基准大的
        if (i <= j) {
            swap(arr[i], arr[j]);
            i++;
            j--;
        }
    }
    quickSort(arr, left, j);
    quickSort(arr, i, right);
}

// 快速排序包装函数（适配函数指针格式）
void quickSortWrapper(vector<BoundingBox>& arr) {
    if (arr.empty()) return;
    quickSort(arr, 0, arr.size() - 1);
}

// 1.2 归并排序
void merge(vector<BoundingBox>& arr, int left, int mid, int right) {
    vector<BoundingBox> temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;
    while (i <= mid && j <= right) {
        if (arr[i].score >= arr[j].score) temp[k++] = arr[i++];
        else temp[k++] = arr[j++];
    }
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    for (int p = 0; p < temp.size(); p++) arr[left + p] = temp[p];
}

void mergeSort(vector<BoundingBox>& arr, int left, int right) {
    if (left >= right) return;
    int mid = (left + right) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

// 归并排序包装函数
void mergeSortWrapper(vector<BoundingBox>& arr) {
    if (arr.empty()) return;
    mergeSort(arr, 0, arr.size() - 1);
}

// 1.3 堆排序
void heapify(vector<BoundingBox>& arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    if (left < n && arr[left].score > arr[largest].score) largest = left;
    if (right < n && arr[right].score > arr[largest].score) largest = right;
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(vector<BoundingBox>& arr) {
    int n = arr.size();
    // 构建大顶堆
    for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);
    // 堆排序（逐个提取堆顶）
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}

// 1.4 冒泡排序（优化版，无交换则提前退出）
void bubbleSort(vector<BoundingBox>& arr) {
    int n = arr.size();
    bool swapped;
    for (int i = 0; i < n - 1; i++) {
        swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j].score < arr[j + 1].score) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        if (!swapped) break; // 已有序，无需继续排序
    }
}

// 2. 数据生成模块（随机分布 + 聚集分布）
// 随机分布：边界框均匀分布在 0~1000 坐标范围，宽高 10~100，置信度 0~1
vector<BoundingBox> generateRandomBoxes(int count) {
    vector<BoundingBox> boxes;
    srand((unsigned int)time(0)); // 显式转换，避免编译警告
    for (int i = 0; i < count; i++) {
        BoundingBox box;
        box.x1 = rand() % 900;          // 左上角x：0~899（确保x2不超1000）
        box.y1 = rand() % 900;          // 左上角y：0~899
        box.x2 = box.x1 + 10 + rand() % 90; // 宽：10~100
        box.y2 = box.y1 + 10 + rand() % 90; // 高：10~100
        box.score = (float)rand() / RAND_MAX; // 置信度：0~1
        boxes.push_back(box);
    }
    return boxes;
}

// 聚集分布：80% 边界框聚集在中心区域（400~600），20% 随机分布
vector<BoundingBox> generateClusteredBoxes(int count) {
    vector<BoundingBox> boxes;
    srand((unsigned int)time(0));
    int clusterCount = count * 0.8; // 聚集区域数量（80%）
    int randomCount = count - clusterCount; // 随机区域数量（20%）

    // 聚集区域生成（中心 400~600，宽高 10~80）
    for (int i = 0; i < clusterCount; i++) {
        BoundingBox box;
        box.x1 = 400 + rand() % 200;        // 左上角x：400~599
        box.y1 = 400 + rand() % 200;        // 左上角y：400~599
        box.x2 = box.x1 + 10 + rand() % 70; // 宽：10~80
        box.y2 = box.y1 + 10 + rand() % 70; // 高：10~80
        box.score = (float)rand() / RAND_MAX;
        boxes.push_back(box);
    }

    // 剩余20%按随机分布生成
    for (int i = 0; i < randomCount; i++) {
        BoundingBox box;
        box.x1 = rand() % 900;
        box.y1 = rand() % 900;
        box.x2 = box.x1 + 10 + rand() % 90;
        box.y2 = box.y1 + 10 + rand() % 90;
        box.score = (float)rand() / RAND_MAX;
        boxes.push_back(box);
    }

    return boxes;
}

// 3. 辅助函数：计算两个边界框的IOU（交并比）
float calculateIOU(const BoundingBox& a, const BoundingBox& b) {
    // 计算交集的左上角和右下角坐标
    float interX1 = max(a.x1, b.x1);
    float interY1 = max(a.y1, b.y1);
    float interX2 = min(a.x2, b.x2);
    float interY2 = min(a.y2, b.y2);

    // 计算交集面积（无交集则为0）
    float interArea = max(0.0f, interX2 - interX1) * max(0.0f, interY2 - interY1);
    // 计算两个框的面积
    float aArea = (a.x2 - a.x1) * (a.y2 - a.y1);
    float bArea = (b.x2 - b.x1) * (b.y2 - b.y1);
    // 计算并集面积
    float unionArea = aArea + bArea - interArea;

    return unionArea == 0 ? 0.0f : interArea / unionArea;
}

// 4. 基础NMS算法实现（IOU阈值0.5，接收排序函数指针）
vector<BoundingBox> nms(vector<BoundingBox> boxes, void (*sortFunc)(vector<BoundingBox>&)) {
    vector<BoundingBox> result;
    if (boxes.empty()) return result;

    // 步骤1：用指定排序算法按置信度降序排序
    sortFunc(boxes);

    // 步骤2：执行NMS过滤
    while (!boxes.empty()) {
        // 取置信度最高的框加入结果
        BoundingBox topBox = boxes[0];
        result.push_back(topBox);
        boxes.erase(boxes.begin()); // 移除已选中的框

        // 过滤与topBox重叠度（IOU）超过阈值的框
        vector<BoundingBox> tempBoxes;
        for (const auto& box : boxes) {
            if (calculateIOU(topBox, box) < 0.5f) {
                tempBoxes.push_back(box);
            }
        }
        boxes = tempBoxes; // 更新剩余框
    }

    return result;
}

// 5. 性能测试模块（计算排序+NMS的总运行时间，单位：毫秒）
double testPerformance(vector<BoundingBox> boxes, void (*sortFunc)(vector<BoundingBox>&),
    const string& sortName, const string& dataType, int size) {
    // 记录开始时间
    clock_t start = clock();

    // 执行NMS（包含排序步骤）
    vector<BoundingBox> nmsResult = nms(boxes, sortFunc);

    // 计算运行时间
    clock_t end = clock();
    double duration = double(end - start) / CLOCKS_PER_SEC * 1000; // 转换为毫秒

    // 格式化输出结果
    cout << left << setw(12) << sortName
        << setw(12) << dataType
        << setw(8) << size
        << setw(12) << fixed << setprecision(2) << duration << "ms"
        << setw(12) << nmsResult.size() << endl;

    return duration;
}

int main() {
    // 实验配置：测试数据规模（100/1000/5000/10000）
    vector<int> testSizes = { 100, 1000, 5000, 10000 };
    // 测试数据类型（随机分布/聚集分布）
    vector<string> dataTypes = { "随机分布", "聚集分布" };
    // 排序算法列表（名称 + 函数指针，兼容C++11，不使用结构化绑定）
    struct SortAlgorithm {
        string name;
        void (*func)(vector<BoundingBox>&);
    };
    vector<SortAlgorithm> sortAlgorithms = {
        {"快速排序", quickSortWrapper},
        {"归并排序", mergeSortWrapper},
        {"堆排序", heapSort},
        {"冒泡排序", bubbleSort}
    };

    // 输出表头
    cout << left << setw(12) << "排序算法"
        << setw(12) << "数据类型"
        << setw(8) << "数据规模"
        << setw(12) << "运行时间"
        << setw(12) << "NMS后剩余框数" << endl;
    cout << string(60, '-') << endl;

    // 遍历所有实验组合（规模+分布+排序算法）
    for (int size : testSizes) {
        for (const string& dataType : dataTypes) {
            // 生成对应类型和规模的边界框数据
            vector<BoundingBox> originalBoxes;
            if (dataType == "随机分布") {
                originalBoxes = generateRandomBoxes(size);
            }
            else {
                originalBoxes = generateClusteredBoxes(size);
            }

            // 对每种排序算法进行性能测试（复制数据避免原数组被修改）
            for (const SortAlgorithm& sa : sortAlgorithms) {
                vector<BoundingBox> boxesCopy = originalBoxes;
                testPerformance(boxesCopy, sa.func, sa.name, dataType, size);
            }
            cout << endl; // 分隔不同数据规模的结果
        }
    }

    return 0;
}
