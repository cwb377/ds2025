#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <climits>
#include <algorithm>
#include <utility> // 确保pair相关头文件包含
using namespace std;

// 图类（支持无向图，权重默认1，无边为0）
class Graph {
private:
    int vertexNum;          // 顶点数
    vector<char> vertices;  // 顶点集合（存储字符标识）
    vector<vector<int>> adjMatrix;  // 邻接矩阵（0表示无边，>0表示权重）

    // 辅助：通过顶点字符获取索引
    int getVertexIndex(char c) const {
        for (int i = 0; i < vertexNum; i++) {
            if (vertices[i] == c) return i;
        }
        return -1; // 未找到
    }

public:
    // 构造函数：初始化顶点集合
    Graph(const vector<char>& vs) : vertices(vs) {
        vertexNum = vs.size();
        // 初始化邻接矩阵为全0（无边）
        adjMatrix.resize(vertexNum, vector<int>(vertexNum, 0));
    }

    // 添加边（无向图：双向赋值）
    void addEdge(char u, char v, int weight = 1) {
        int i = getVertexIndex(u);
        int j = getVertexIndex(v);
        if (i != -1 && j != -1) {
            adjMatrix[i][j] = weight;
            adjMatrix[j][i] = weight;
        }
    }

    // 输出邻接矩阵
    void printAdjMatrix() const {
        // 打印顶点表头
        cout << "邻接矩阵（顶点顺序：";
        for (char c : vertices) cout << c << " ";
        cout << "）：\n";

        for (int i = 0; i < vertexNum; i++) {
            cout << vertices[i] << " ";
            for (int j = 0; j < vertexNum; j++) {
                cout << adjMatrix[i][j] << " ";
            }
            cout << "\n";
        }
    }

    // 1. BFS 遍历（从起点s出发）
    void BFS(char start) const {
        int s = getVertexIndex(start);
        if (s == -1) { cout << "起点不存在！\n"; return; }

        vector<bool> visited(vertexNum, false);
        queue<int> q;

        visited[s] = true;
        q.push(s);

        cout << "BFS 遍历（起点" << start << "）：";
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            cout << vertices[u] << " ";

            // 遍历所有邻接顶点
            for (int v = 0; v < vertexNum; v++) {
                if (adjMatrix[u][v] != 0 && !visited[v]) {
                    visited[v] = true;
                    q.push(v);
                }
            }
        }
        cout << "\n";
    }

    // 2. DFS 遍历（递归实现，从起点s出发）
    void DFS(char start) const {
        int s = getVertexIndex(start);
        if (s == -1) { cout << "起点不存在！\n"; return; }

        vector<bool> visited(vertexNum, false);
        cout << "DFS 遍历（起点" << start << "）：";
        DFSRecursive(s, visited);
        cout << "\n";
    }

private:
    void DFSRecursive(int u, vector<bool>& visited) const {
        visited[u] = true;
        cout << vertices[u] << " ";

        for (int v = 0; v < vertexNum; v++) {
            if (adjMatrix[u][v] != 0 && !visited[v]) {
                DFSRecursive(v, visited);
            }
        }
    }

public:
    // 3. 最短路径算法（Dijkstra，单源最短路径，权重为正）
    void Dijkstra(char start) const {
        int s = getVertexIndex(start);
        if (s == -1) { cout << "起点不存在！\n"; return; }

        vector<int> dist(vertexNum, INT_MAX);  // 起点到各顶点的距离
        vector<bool> visited(vertexNum, false); // 是否确定最短路径
        vector<char> prev(vertexNum, ' ');     // 前驱顶点（用于还原路径）

        dist[s] = 0; // 起点到自身距离为0

        // 迭代 vertexNum 次（每次确定一个顶点的最短路径）
        for (int i = 0; i < vertexNum; i++) {
            // 找到当前未访问的距离最小的顶点
            int minDist = INT_MAX;
            int u = -1;
            for (int j = 0; j < vertexNum; j++) {
                if (!visited[j] && dist[j] < minDist) {
                    minDist = dist[j];
                    u = j;
                }
            }

            if (u == -1) break; // 剩余顶点不可达
            visited[u] = true;

            // 松弛操作：更新邻接顶点的距离
            for (int v = 0; v < vertexNum; v++) {
                if (adjMatrix[u][v] != 0 && !visited[v] && dist[u] != INT_MAX) {
                    int newDist = dist[u] + adjMatrix[u][v];
                    if (newDist < dist[v]) {
                        dist[v] = newDist;
                        prev[v] = vertices[u];
                    }
                }
            }
        }

        // 输出结果
        cout << "Dijkstra 最短路径（起点" << start << "）：\n";
        for (int i = 0; i < vertexNum; i++) {
            cout << start << " -> " << vertices[i] << "：";
            if (dist[i] == INT_MAX) {
                cout << "不可达\n";
            }
            else {
                cout << "距离=" << dist[i] << "，路径：";
                // 还原路径（从终点回溯到起点）
                stack<char> path;
                char cur = vertices[i];
                while (cur != ' ') {
                    path.push(cur);
                    cur = prev[getVertexIndex(cur)];
                }
                // 输出路径
                while (!path.empty()) {
                    cout << path.top();
                    path.pop();
                    if (!path.empty()) cout << "->";
                }
                cout << "\n";
            }
        }
    }

    // 4. 最小支撑树（Prim 算法，从起点s出发）
    void Prim(char start) const {
        int s = getVertexIndex(start);
        if (s == -1) { cout << "起点不存在！\n"; return; }

        vector<int> key(vertexNum, INT_MAX);    // 顶点到MST的最小权重
        vector<char> parent(vertexNum, ' ');    // MST中的父节点
        vector<bool> inMST(vertexNum, false);   // 是否已加入MST

        key[s] = 0; // 起点权重为0

        // 迭代 vertexNum 次（构建MST需要n-1条边）
        for (int i = 0; i < vertexNum; i++) {
            // 找到未加入MST且key最小的顶点
            int minKey = INT_MAX;
            int u = -1;
            for (int j = 0; j < vertexNum; j++) {
                if (!inMST[j] && key[j] < minKey) {
                    minKey = key[j];
                    u = j;
                }
            }

            if (u == -1) { cout << "图不连通，无法构建MST！\n"; return; }
            inMST[u] = true;

            // 更新邻接顶点的key值
            for (int v = 0; v < vertexNum; v++) {
                if (adjMatrix[u][v] != 0 && !inMST[v] && adjMatrix[u][v] < key[v]) {
                    key[v] = adjMatrix[u][v];
                    parent[v] = vertices[u];
                }
            }
        }

        // 输出MST结果
        cout << "Prim 最小支撑树（起点" << start << "）：\n";
        int totalWeight = 0;
        for (int i = 0; i < vertexNum; i++) {
            if (parent[i] != ' ') {
                cout << parent[i] << " - " << vertices[i] << "（权重：" << key[i] << "）\n";
                totalWeight += key[i];
            }
        }
        cout << "MST 总权重：" << totalWeight << "\n";
    }

    // 5. 双连通分量与关节点检测（Tarjan 算法，无向图）
    void findBiconnectedComponents() const {
        vector<int> disc(vertexNum, -1);    // 发现时间
        vector<int> low(vertexNum, -1);     // 能到达的最早发现时间的顶点
        vector<bool> visited(vertexNum, false);
        vector<bool> isArticulation(vertexNum, false); // 是否为关节点
        vector<char> parent(vertexNum, ' '); // 父节点
        stack<pair<char, char>> edgeStack;  // 存储当前边
        int time = 0;

        cout << "双连通分量（BCC）与关节点检测：\n";
        // 处理非连通图（遍历所有未访问顶点）
        for (int i = 0; i < vertexNum; i++) {
            if (!visited[i]) {
                tarjanBCC(i, visited, disc, low, parent, edgeStack, isArticulation, time);
                // 处理剩余边（当前连通分量的最后一个BCC）
                if (!edgeStack.empty()) {
                    cout << "BCC：";
                    while (!edgeStack.empty()) {
                        // 修复点1：移除结构化绑定，直接访问pair的first/second
                        pair<char, char> topEdge = edgeStack.top();
                        edgeStack.pop();
                        cout << "(" << topEdge.first << "," << topEdge.second << ") ";
                    }
                    cout << "\n";
                }
            }
        }

        // 输出关节点
        cout << "关节点（Articulation Points）：";
        for (int i = 0; i < vertexNum; i++) {
            if (isArticulation[i]) {
                cout << vertices[i] << " ";
            }
        }
        cout << "\n";
    }

private:
    void tarjanBCC(int u, vector<bool>& visited, vector<int>& disc, vector<int>& low,
        vector<char>& parent, stack<pair<char, char>>& edgeStack,
        vector<bool>& isArticulation, int& time) const {
        visited[u] = true;
        disc[u] = low[u] = ++time;
        int children = 0; // 子节点数（根节点特殊处理）

        for (int v = 0; v < vertexNum; v++) {
            if (adjMatrix[u][v] == 0) continue; // 无边
            if (!visited[v]) {
                children++;
                parent[v] = vertices[u];
                edgeStack.push({ vertices[u], vertices[v] }); // 压入边

                // 递归处理子节点
                tarjanBCC(v, visited, disc, low, parent, edgeStack, isArticulation, time);

                // 更新当前顶点的low值（子节点能到达的最早时间）
                low[u] = min(low[u], low[v]);

                // 情况1：根节点且子节点数>=2（根节点是关节点）
                if (parent[u] == ' ' && children > 1) {
                    isArticulation[u] = true;
                    // 弹出当前BCC的所有边
                    cout << "BCC：";
                    while (true) {
                        // 修复点2：移除结构化绑定，直接访问pair成员
                        pair<char, char> topEdge = edgeStack.top();
                        edgeStack.pop();
                        cout << "(" << topEdge.first << "," << topEdge.second << ") ";
                        if (topEdge.first == vertices[u] && topEdge.second == vertices[v]) {
                            break;
                        }
                    }
                    cout << "\n";
                }

                // 情况2：非根节点，low[v] >= disc[u]（u是关节点）
                if (parent[u] != ' ' && low[v] >= disc[u]) {
                    isArticulation[u] = true;
                    // 弹出当前BCC的所有边
                    cout << "BCC：";
                    while (true) {
                        // 修复点3：移除结构化绑定，直接访问pair成员
                        pair<char, char> topEdge = edgeStack.top();
                        edgeStack.pop();
                        cout << "(" << topEdge.first << "," << topEdge.second << ") ";
                        if (topEdge.first == vertices[u] && topEdge.second == vertices[v]) {
                            break;
                        }
                    }
                    cout << "\n";
                }
            }
            // 情况3：访问过的节点是父节点的祖先（回边），更新low[u]
            else if (v != getVertexIndex(parent[u])) {
                low[u] = min(low[u], disc[v]);
                // 回边压入栈（避免重复）
                if (disc[v] < disc[u]) { // 确保边只压入一次（u在v之后发现）
                    edgeStack.push({ vertices[u], vertices[v] });
                }
            }
        }
    }
};

// 构建图1（根据题目描述还原，假设顶点为A,B,C,D,E,F,G,H,I,J,K,L）
Graph buildGraph1() {
    vector<char> vertices = { 'A','B','C','D','E','F','G','H','I','J','K','L' };
    Graph g(vertices);

    // 根据题目图1的边权重添加边（需与题目图结构一致，此处按常见还原）
    g.addEdge('A', 'B', 2);
    g.addEdge('A', 'I', 10);
    g.addEdge('B', 'C', 12);
    g.addEdge('B', 'E', 9);
    g.addEdge('C', 'E', 1);
    g.addEdge('D', 'B', 4);
    g.addEdge('D', 'G', 2);
    g.addEdge('E', 'F', 5);
    g.addEdge('E', 'G', 11);
    g.addEdge('F', 'H', 3);
    g.addEdge('F', 'K', 8);
    g.addEdge('G', 'F', 14);
    g.addEdge('H', 'L', 2);
    g.addEdge('I', 'J', 3);
    g.addEdge('J', 'K', 13);
    g.addEdge('K', 'L', 6);

    return g;
}

// 构建图2（题目指定顶点：A,B,C,D,E,F,G,H,I,J,K,L）
Graph buildGraph2() {
    vector<char> vertices = { 'A','B','C','D','E','F','G','H','I','J','K','L' };
    Graph g(vertices);

    // 图2为连通图（示例边，可根据实际题目图调整，不影响算法逻辑）
    g.addEdge('A', 'B');
    g.addEdge('A', 'C');
    g.addEdge('B', 'C');
    g.addEdge('B', 'D');
    g.addEdge('C', 'E');
    g.addEdge('D', 'E');
    g.addEdge('D', 'F');
    g.addEdge('E', 'F');
    g.addEdge('F', 'G');
    g.addEdge('G', 'H');
    g.addEdge('H', 'I');
    g.addEdge('I', 'J');
    g.addEdge('J', 'K');
    g.addEdge('K', 'L');
    g.addEdge('L', 'G');

    return g;
}

int main() {
    // -------------------------- 实验(1)(2)(3)：图1操作 --------------------------
    cout << "===================== 图1 操作 =====================\n";
    Graph g1 = buildGraph1();

    // (1) 输出图1邻接矩阵
    cout << "\n(1) 图1邻接矩阵：\n";
    g1.printAdjMatrix();

    // (2) 图1从A出发的BFS和DFS
    cout << "\n(2) 图1从A出发的遍历：\n";
    g1.BFS('A');
    g1.DFS('A');

    // (3) 图1从A出发的最短路径和最小支撑树
    cout << "\n(3) 图1从A出发的最短路径（Dijkstra）：\n";
    g1.Dijkstra('A');
    cout << "\n(3) 图1从A出发的最小支撑树（Prim）：\n";
    g1.Prim('A');

    // -------------------------- 实验(4)：图2双连通分量与关节点 --------------------------
    cout << "\n\n===================== 图2 操作 =====================\n";
    Graph g2 = buildGraph2();

    // (4) 图2选取不同起点计算双连通分量和关节点（结果一致）
    cout << "(4) 图2以A为起点：\n";
    g2.findBiconnectedComponents();

    cout << "\n(4) 图2以F为起点（验证结果一致性）：\n";
    g2.findBiconnectedComponents();

    return 0;
}
